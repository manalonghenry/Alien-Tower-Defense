#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>
#include <map>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>

#include "render_system.hpp"

#include <functional> // for std::hash
#include <glm/vec2.hpp>

namespace std {
	template<>
	struct hash<glm::ivec2> {
		std::size_t operator()(const glm::ivec2& v) const noexcept {
			std::size_t h1 = std::hash<int>()(v.x);
			std::size_t h2 = std::hash<int>()(v.y);
			return h1 ^ (h2 << 1);
		}
	};
}

#include <unordered_set>
#include <unordered_map>
#include <vector>
#include "glm/vec2.hpp"
#include "glm/vec3.hpp"


// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:

	bool showpath = true;
	bool invader_respawns = false;
	bool showfilledtiles = false;
	WorldSystem();

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem* renderer_arg);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	void clearAllText();

	void addUnspawnedText(int invadersUnspawned);

	void addScoreText(int score);

	void addTextForIntro(int level);

	void addIntroError(int level);

	void addGameOverText();

	void addVictoryText();

	void end_game();

	void createExplosion(vec2 position);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// A2: update the window caption (title)
	void update_window_caption();

	// A2: report the current game screen
	GAME_SCREEN_ID get_game_screen() { return game_screen; }

	// A2: saving and loading levels
	std::string world_level_filename = "level0.txt";
	bool load_level(const std::string& filename);
	bool save_level(const std::string& filename);
	bool find_path(std::vector<ivec2>& path);

	// A2: world level
	bool find_first_start_tile(glm::ivec2& start_tile);
	bool find_first_exit_tile(glm::ivec2& exit_tile);

	// bool invader_respawns = false;
	
	
	
	ivec2 getStartTile();

private:

	// PhysicsSystem* physics_system = nullptr;
	ivec2 startTile;
	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;
	// float next_invader_spawn = 0;
	int level = 0;
	int score = 0;
	bool validLevel = true;
	int invaders_remaining = 0;
	vec2 spawn_start_position;
	std::vector<ivec2> spawn_path;
	float next_invader_spawn = 0;

	bool victory = false;

	Tile* getTileAt(const glm::ivec2& coord);

	// to better support uses with track pads and macOS, holding SHIFT + LEFT-CLICK will be a right-click
	bool shift_key_pressed = false;

	// A2: default tile (for drawing map)
	TEXTURE_ASSET_ID drawing_tile = TEXTURE_ASSET_ID::MAPTILE_121;

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// ADDED
	void remove_tile(int x, int y);
	void place_tile(int x, int y, TEXTURE_ASSET_ID tile_type);
	void render_tile_selector();
	void start_game();
	bool canConnect(const Tile& current, const Tile& neighbor, const glm::ivec2& direction);

	bool find_path_with_visitation(std::vector<glm::ivec2>& path, std::unordered_set<glm::ivec2>& visited);
	void clear_filled_tiles();

	// restart level
	void restart_game();

	// OpenGL window handle
	GLFWwindow* window;

	// float next_invader_spawn;
	int invader_spawn_rate_ms;	// see default value in common.hpp

	int max_towers;	// see default value in common.hpp

	// Number of invaders stopped by the towers, displayed in the window title
	unsigned int points;

	// Game state
	RenderSystem* renderer;
	float current_speed;
	GAME_SCREEN_ID game_screen = GAME_SCREEN_ID::INTRO;

	// grid
	std::vector<Entity> grid_lines;

	// music references
	Mix_Music* background_music;
	Mix_Chunk* chicken_dead_sound;
	Mix_Chunk* chicken_eat_sound;

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1
};
